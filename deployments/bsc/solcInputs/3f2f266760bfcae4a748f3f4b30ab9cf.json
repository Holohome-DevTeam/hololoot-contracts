{
  "language": "Solidity",
  "sources": {
    "contracts/abstract/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nabstract contract FeeManager {\n    /// @notice token address\n    address public token;\n\n    constructor(address _token) {\n        require(_token != address(0), \"_token address cannot be 0\");\n        token = _token;\n        _lock = _NOT_LOCKED;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == token, \"only token\");\n        _;\n    }\n\n    uint256 private constant _NOT_LOCKED = 1;\n    uint256 private constant _LOCKED = 2;\n    uint256 private _lock;\n\n    modifier lock() {\n        if (_lock == _NOT_LOCKED) {\n            _lock = _LOCKED;\n            _;\n            _lock = _NOT_LOCKED;\n        }\n    }\n\n    function syncFee() external onlyToken lock {\n        _syncFee();\n    }\n\n    function canSyncFee(address sender, address recipient) external view virtual returns (bool shouldSyncFee);\n\n    function _syncFee() internal virtual;\n}\n"
    },
    "contracts/mocks/FeeManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable no-empty-blocks */\npragma solidity 0.8.6;\n\nimport { FeeManager } from \"../abstract/FeeManager.sol\";\n\ncontract FeeManagerMock is FeeManager {\n    bool private shouldSync;\n\n    /**\n     * @param _token token address\n     */\n    constructor(address _token) FeeManager(_token) {}\n\n    function canSyncFee(address, address) external view override returns (bool shouldSyncFee) {\n        return shouldSync;\n    }\n\n    function _syncFee() internal override {}\n\n    function setSync(bool sync) external {\n        shouldSync = sync;\n    }\n}\n"
    },
    "contracts/fee/HoloFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable no-empty-blocks */\npragma solidity 0.8.6;\n\nimport { IUniswapV2Pair } from \"../external/uniswap/IUniswapV2Pair.sol\";\nimport { IUniswapV2Router02 } from \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\nimport { Ownable } from \"../helpers/Ownable.sol\";\nimport { FeeManager } from \"../abstract/FeeManager.sol\";\n\ncontract HoloFeeManager is FeeManager, Ownable {\n    /// @notice address of wrapped BNB\n    address public wBNB;\n\n    /// @notice address of LP mint\n    address public lpMint;\n\n    /// @notice uniswap V2 pair address\n    IUniswapV2Pair public uniswapPair;\n    /// @notice uniswap V2 router\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice min amount of tokens to trigger sync\n    uint256 public minTokens;\n\n    /// @notice fee distribution\n    uint256 public burnFeeAlloc = 0;\n    uint256 public lpFeeAlloc = 100;\n    uint256 public totalFeeAlloc = burnFeeAlloc + lpFeeAlloc;\n\n    constructor(address _token, address _wBNB) FeeManager(_token) {\n        require(_wBNB != address(0), \"_wBNB address cannot be 0\");\n        wBNB = _wBNB;\n        minTokens = 500 * 10**18;\n    }\n\n    function setUniswap(address _uniswapPair, address _uniswapRouter) external onlyOwner {\n        require(_uniswapPair != address(0), \"_uniswapPair address cannot be 0\");\n        require(_uniswapRouter != address(0), \"_uniswapRouter address cannot be 0\");\n        uniswapPair = IUniswapV2Pair(_uniswapPair);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n\n        IERC20(token).approve(address(uniswapRouter), 0);\n        IERC20(token).approve(address(uniswapRouter), type(uint256).max);\n        IERC20(wBNB).approve(address(uniswapRouter), 0);\n        IERC20(wBNB).approve(address(uniswapRouter), type(uint256).max);\n    }\n\n    function canSyncFee(address, address recipient) external view override returns (bool shouldSyncFee) {\n        if (recipient == address(uniswapPair)) {\n            shouldSyncFee = true;\n        }\n    }\n\n    function _syncFee() internal override {\n        uint256 totalAmount = IERC20(token).balanceOf(address(this));\n        uint256 burnAmount;\n\n        if (totalAmount >= minTokens && totalFeeAlloc > 0) {\n            burnAmount = (totalAmount * burnFeeAlloc) / totalFeeAlloc;\n\n            if (burnAmount > 0) {\n                IERC20(token).burn(burnAmount);\n            }\n\n            uint256 lpAmount = totalAmount - burnAmount;\n\n            if (lpAmount >= 2) {\n                uint256 swapAmount = lpAmount / 2;\n                uint256 liquidityAmount = lpAmount - swapAmount;\n\n                // swap half for BNB\n                uint256 preBNB = IERC20(wBNB).balanceOf(address(this));\n                _swapTokens(swapAmount);\n                uint256 postBNB = IERC20(wBNB).balanceOf(address(this));\n\n                // add other half with received BNB\n                _addTokensToLiquidity(liquidityAmount, postBNB - preBNB);\n            }\n        }\n    }\n\n    function _swapTokens(uint256 amount) private {\n        address[] memory path = new address[](2);\n\n        path[0] = token;\n        path[1] = wBNB;\n\n        try uniswapRouter.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp) {} catch {}\n    }\n\n    function _addTokensToLiquidity(uint256 tokenAmount, uint256 wBNBAmount) private {\n        if (tokenAmount != 0 && wBNBAmount != 0) {\n            address destination = (lpMint != address(0)) ? lpMint : address(this);\n\n            try uniswapRouter.addLiquidity(token, wBNB, tokenAmount, wBNBAmount, 0, 0, destination, block.timestamp) {} catch {}\n        }\n    }\n\n    function setLpMint(address _lpMint) public onlyOwner {\n        lpMint = _lpMint;\n    }\n\n    function setMinTokens(uint256 _minTokens) public onlyOwner {\n        require(_minTokens >= 100, \"not less then 100\");\n        minTokens = _minTokens;\n    }\n\n    function setFeeAlloc(uint256 _burnFeeAlloc, uint256 _lpFeeAlloc) public onlyOwner {\n        require(_burnFeeAlloc >= 0 && _burnFeeAlloc <= 100, \"_burnFeeAlloc is outside of range 0-100\");\n        require(_lpFeeAlloc >= 0 && _lpFeeAlloc <= 100, \"_lpFeeAlloc is outside of range 0-100\");\n        burnFeeAlloc = _burnFeeAlloc;\n        lpFeeAlloc = _lpFeeAlloc;\n        totalFeeAlloc = burnFeeAlloc + lpFeeAlloc;\n    }\n\n    function recoverBNB() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function recoverBep20(address _token) external onlyOwner {\n        uint256 amt = IERC20(_token).balanceOf(address(this));\n        require(amt > 0, \"nothing to recover\");\n        IBadErc20(_token).transfer(owner, amt);\n    }\n}\n\ninterface IBadErc20 {\n    function transfer(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/* solhint-disable func-name-mixedcase */\npragma solidity 0.8.6;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"./IUniswapV2Router01.sol\";\n\n/**\n * @title Uniswap V2 router02 interface\n */\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    // external functions\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function burn(uint256 amount) external returns (bool);\n\n    function burnFrom(address account, uint256 amount) external returns (bool);\n\n    // EIP 2612\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/helpers/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\ncontract OwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract Ownable is OwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev `owner` defaults to msg.sender on construction.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n     *      Can only be invoked by the current `owner`.\n     * @param _newOwner Address of the new owner.\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\n     */\n    function transferOwnership(\n        address _newOwner,\n        bool _direct,\n        bool _renounce\n    ) external onlyOwner {\n        if (_direct) {\n            require(_newOwner != address(0) || _renounce, \"zero address\");\n\n            emit OwnershipTransferred(owner, _newOwner);\n            owner = _newOwner;\n            pendingOwner = address(0);\n        } else {\n            pendingOwner = _newOwner;\n        }\n    }\n\n    /**\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\n     */\n    function claimOwnership() external {\n        address _pendingOwner = pendingOwner;\n        require(msg.sender == _pendingOwner, \"caller != pending owner\");\n\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function _setOwner(address newOwner) internal {\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/* solhint-disable func-name-mixedcase */\npragma solidity 0.8.6;\n\n/**\n * @title Uniswap V2 router01 interface\n */\ninterface IUniswapV2Router01 {\n    // external functions\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256, uint256);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256, uint256);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256, uint256);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256, uint256);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory);\n\n    // external functions (views)\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory);\n\n    // external functions (pure)\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256);\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n}\n"
    },
    "contracts/vesting/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { StableMath } from \"../libraries/StableMath.sol\";\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\nimport { Ownable } from \"../helpers/Ownable.sol\";\nimport { Lockable } from \"../helpers/Lockable.sol\";\n\n/**\n * @title   Vesting\n * @notice  Vesting contract\n * @dev     Vesting is constantly releasing vested tokens every block every second\n */\ncontract Vesting is Ownable, Lockable {\n    using StableMath for uint256;\n\n    /// @notice address of vested token\n    address public token;\n    /// @notice total tokens vested in contract\n    uint256 public totalVested;\n    /// @notice total tokens already claimed form vesting\n    uint256 public totalClaimed;\n\n    struct Vest {\n        uint256 dateStart; // start of claiming, can claim startTokens\n        uint256 dateEnd; // after it all tokens can be claimed\n        uint256 totalTokens; // total tokens to claim\n        uint256 startTokens; // tokens to claim on start\n        uint256 claimedTokens; // tokens already claimed\n    }\n    /// @notice storage of vestings\n    Vest[] internal vestings;\n    /// @notice map of vestings for user\n    mapping(address => uint256[]) internal user2vesting;\n\n    /// @dev events\n    event Claimed(address indexed user, uint256 amount);\n    event Vested(address indexed user, uint256 totalAmount, uint256 endDate);\n\n    /**\n     * @dev Contract initiator\n     * @param _token address of vested token\n     */\n    function init(address _token) external onlyOwner {\n        require(_token != address(0), \"_token address cannot be 0\");\n        require(token == address(0), \"init already done\");\n        token = _token;\n    }\n\n    /**\n     * @dev Add multiple vesting to contract by arrays of data\n     * @param _users[] addresses of holders\n     * @param _startTokens[] tokens that can be withdrawn at startDate\n     * @param _totalTokens[] total tokens in vesting\n     * @param _startDate date from when tokens can be claimed\n     * @param _endDate date after which all tokens can be claimed\n     */\n    function massAddHolders(\n        address[] calldata _users,\n        uint256[] calldata _startTokens,\n        uint256[] calldata _totalTokens,\n        uint256 _startDate,\n        uint256 _endDate\n    ) external onlyOwner whenNotLocked {\n        uint256 len = _users.length; //cheaper to use one variable\n        require((len == _startTokens.length) && (len == _totalTokens.length), \"data size mismatch\");\n        require(_startDate < _endDate, \"startDate cannot exceed endDate\");\n        uint256 i;\n        for (i; i < len; i++) {\n            _addHolder(_users[i], _startTokens[i], _totalTokens[i], _startDate, _endDate);\n        }\n    }\n\n    /**\n     * @dev Add new vesting to contract\n     * @param _user address of a holder\n     * @param _startTokens how many tokens are claimable at start date\n     * @param _totalTokens total number of tokens in added vesting\n     * @param _startDate date from when tokens can be claimed\n     * @param _endDate date after which all tokens can be claimed\n     */\n    function _addHolder(\n        address _user,\n        uint256 _startTokens,\n        uint256 _totalTokens,\n        uint256 _startDate,\n        uint256 _endDate\n    ) internal {\n        require(_user != address(0), \"user address cannot be 0\");\n        Vest memory v;\n        v.startTokens = _startTokens;\n        v.totalTokens = _totalTokens;\n        v.dateStart = _startDate;\n        v.dateEnd = _endDate;\n\n        totalVested += _totalTokens;\n        vestings.push(v);\n        user2vesting[_user].push(vestings.length); // we are skipping index \"0\" for reasons\n        emit Vested(_user, _totalTokens, _endDate);\n    }\n\n    /**\n     * @dev Claim tokens from msg.sender vestings\n     */\n    function claim() external {\n        _claim(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev Claim tokens from msg.sender vestings to external address\n     * @param _target transfer address for claimed tokens\n     */\n    function claimTo(address _target) external {\n        _claim(msg.sender, _target);\n    }\n\n    /**\n     * @dev internal claim function\n     * @param _user address of holder\n     * @param _target where tokens should be send\n     * @return amt number of tokens claimed\n     */\n    function _claim(address _user, address _target) internal returns (uint256 amt) {\n        require(_target != address(0), \"claim, then burn\");\n        uint256 len = user2vesting[_user].length;\n        require(len > 0, \"no vestings for user\");\n        uint256 cl;\n        uint256 i;\n        for (i; i < len; i++) {\n            Vest storage v = vestings[user2vesting[_user][i] - 1];\n            cl = _claimable(v);\n            v.claimedTokens += cl;\n            amt += cl;\n        }\n        if (amt > 0) {\n            totalClaimed += amt;\n            _transfer(_target, amt);\n            emit Claimed(_user, amt);\n        } else revert(\"nothing to claim\");\n    }\n\n    /**\n     * @dev Internal function to send out claimed tokens\n     * @param _user address that we send tokens\n     * @param _amt amount of tokens\n     */\n    function _transfer(address _user, uint256 _amt) internal {\n        require(IERC20(token).transfer(_user, _amt), \"token transfer failed\");\n    }\n\n    /**\n     * @dev Count how many tokens can be claimed from vesting to date\n     * @param _vesting Vesting object\n     * @return canWithdraw number of tokens\n     */\n    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {\n        uint256 currentTime = block.timestamp;\n        if (_vesting.dateStart > currentTime) return 0;\n        // we are somewhere in the middle\n        if (currentTime < _vesting.dateEnd) {\n            // how much time passed (as fraction * 10^18)\n            // timeRatio = (time passed * 1e18) / duration\n            uint256 timeRatio = (currentTime - _vesting.dateStart).divPrecisely(_vesting.dateEnd - _vesting.dateStart);\n            // how much tokens we can get in total to date\n            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;\n        }\n        // time has passed, we can take all tokens\n        else {\n            canWithdraw = _vesting.totalTokens;\n        }\n        // but maybe we take something earlier?\n        canWithdraw -= _vesting.claimedTokens;\n    }\n\n    /**\n     * @dev Read number of claimable tokens by user and vesting no\n     * @param _user address of holder\n     * @param _id his vesting number (starts from 0)\n     * @return amount number of tokens\n     */\n    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {\n        amount = _claimable(vestings[user2vesting[_user][_id] - 1]);\n    }\n\n    /**\n     * @dev Read total amount of tokens that user can claim to date from all vestings\n     *      Function also includes tokens to claim from sale contracts that were not\n     *      yet initiated for user.\n     * @param _user address of holder\n     * @return amount number of tokens\n     */\n    function getAllClaimable(address _user) public view returns (uint256 amount) {\n        uint256 len = user2vesting[_user].length;\n        uint256 i;\n        for (i; i < len; i++) {\n            amount += _claimable(vestings[user2vesting[_user][i] - 1]);\n        }\n    }\n\n    /**\n     * @dev Extract all the vestings for the user\n     *      Also extract not initialized vestings from\n     *      sale contracts.\n     * @param _user address of holder\n     * @return v array of Vest objects\n     */\n    function getVestings(address _user) external view returns (Vest[] memory) {\n        uint256 len = user2vesting[_user].length;\n        Vest[] memory v = new Vest[](len);\n\n        // copy vestings\n        uint256 i;\n        for (i; i < len; i++) {\n            v[i] = vestings[user2vesting[_user][i] - 1];\n        }\n\n        return v;\n    }\n\n    /**\n     * @dev Read total number of vestings registered\n     * @return number of registered vestings on contract\n     */\n    function getVestingsCount() external view returns (uint256) {\n        return vestings.length;\n    }\n\n    /**\n     * @dev Read single registered vesting entry\n     * @param _id index of vesting in storage\n     * @return Vest object\n     */\n    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {\n        return vestings[_id];\n    }\n\n    /**\n     * @dev Read registered vesting list by range from-to\n     * @param _start first index\n     * @param _end last index\n     * @return array of Vest objects\n     */\n    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {\n        uint256 cnt = _end - _start + 1;\n        uint256 len = vestings.length;\n        require(_end < len, \"range error\");\n        Vest[] memory v = new Vest[](cnt);\n        uint256 i;\n        for (i; i < cnt; i++) {\n            v[i] = vestings[_start + i];\n        }\n        return v;\n    }\n\n    /**\n     * @dev Recover ETH from contract to owner address.\n     */\n    function recoverETH() external {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    /**\n     * @dev Recover given ERC20 token from contract to owner address.\n     *      Can't recover vested tokens.\n     * @param _token address of ERC20 token to recover\n     */\n    function recoverErc20(address _token) external {\n        require(_token != token, \"not allowed\");\n        uint256 amt = IERC20(_token).balanceOf(address(this));\n        require(amt > 0, \"nothing to recover\");\n        IBadErc20(_token).transfer(owner, amt);\n    }\n}\n\n/**\n * @title IBadErc20\n * @dev Interface for emergency recover any ERC20-tokens,\n *      even non-erc20-compliant like USDT not returning boolean\n */\ninterface IBadErc20 {\n    function transfer(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/StableMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.6;\n\n// Based on StableMath from mStable\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\n\nlibrary StableMath {\n    /**\n     * @dev Scaling unit for use in specific calculations,\n     * where 1 * 10**18, or 1e18 represents a unit '1'\n     */\n    uint256 private constant FULL_SCALE = 1e18;\n\n    /**\n     * @dev Provides an interface to the scaling unit\n     * @return Scaling unit (1e18 or 1 * 10**18)\n     */\n    function getFullScale() internal pure returns (uint256) {\n        return FULL_SCALE;\n    }\n\n    /**\n     * @dev Scales a given integer to the power of the full scale.\n     * @param x   Simple uint256 to scale\n     * @return    Scaled value a to an exact number\n     */\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\n        return x * FULL_SCALE;\n    }\n\n    /***************************************\n              PRECISE ARITHMETIC\n    ****************************************/\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale\n     * @param x     Left hand input to multiplication\n     * @param y     Right hand input to multiplication\n     * @return      Result after multiplying the two inputs and then dividing by the shared\n     *              scale unit\n     */\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulTruncateScale(x, y, FULL_SCALE);\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n     * @param x     Left hand input to multiplication\n     * @param y     Right hand input to multiplication\n     * @param scale Scale unit\n     * @return      Result after multiplying the two inputs and then dividing by the shared\n     *              scale unit\n     */\n    function mulTruncateScale(\n        uint256 x,\n        uint256 y,\n        uint256 scale\n    ) internal pure returns (uint256) {\n        // e.g. assume scale = fullScale\n        // z = 10e18 * 9e17 = 9e36\n        // return 9e36 / 1e18 = 9e18\n        return (x * y) / scale;\n    }\n\n    /**\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n     * @param x     Left hand input to multiplication\n     * @param y     Right hand input to multiplication\n     * @return      Result after multiplying the two inputs and then dividing by the shared\n     *              scale unit, rounded up to the closest base unit.\n     */\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n        // e.g. 8e17 * 17268172638 = 138145381104e17\n        uint256 scaled = x * y;\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n        uint256 ceil = scaled + FULL_SCALE - 1;\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n        return ceil / FULL_SCALE;\n    }\n\n    /**\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n     * @param x     Left hand input to division\n     * @param y     Right hand input to division\n     * @return      Result after multiplying the left operand by the scale, and\n     *              executing the division on the right hand input.\n     */\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\n        // e.g. 8e18 * 1e18 = 8e36\n        // e.g. 8e36 / 10e18 = 8e17\n        return (x * FULL_SCALE) / y;\n    }\n\n    /***************************************\n                    HELPERS\n    ****************************************/\n\n    /**\n     * @dev Calculates minimum of two numbers\n     * @param x     Left hand input\n     * @param y     Right hand input\n     * @return      Minimum of the two inputs\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /**\n     * @dev Calculated maximum of two numbers\n     * @param x     Left hand input\n     * @param y     Right hand input\n     * @return      Maximum of the two inputs\n     */\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x : y;\n    }\n\n    /**\n     * @dev Clamps a value to an upper bound\n     * @param x           Left hand input\n     * @param upperBound  Maximum possible value to return\n     * @return            Input x clamped to a maximum value, upperBound\n     */\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\n        return x > upperBound ? upperBound : x;\n    }\n}\n"
    },
    "contracts/helpers/Lockable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { Ownable } from \"./Ownable.sol\";\n\ncontract LockableData {\n    bool public locked;\n}\n\ncontract Lockable is LockableData, Ownable {\n    /**\n     * @dev Locks functions with whenNotLocked modifier\n     */\n    function lock() external onlyOwner {\n        locked = true;\n    }\n\n    /**\n     * @dev Throws if called when unlocked.\n     */\n    modifier whenLocked {\n        require(locked, \"Lockable: unlocked\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called after it was locked.\n     */\n    modifier whenNotLocked {\n        require(!locked, \"Lockable: locked\");\n        _;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: Transfer failed\");\n    }\n\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: TransferFrom failed\");\n    }\n\n    function safeTransferFromDeluxe(IERC20 token, address from, uint256 amount) internal returns (uint256) {\n        uint256 preBalance = token.balanceOf(address(this));\n        safeTransferFrom(token, from, amount);\n        uint256 postBalance = token.balanceOf(address(this));\n        return postBalance - preBalance;\n    }\n}\n"
    },
    "contracts/staking/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { ReentrancyGuard } from \"../external/openzeppelin/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"../libraries/SafeERC20.sol\";\nimport { StableMath } from \"../libraries/StableMath.sol\";\n\nimport { RewardsDistribution } from \"../helpers/RewardsDistribution.sol\";\nimport { Parameterized } from \"../helpers/Parameterized.sol\";\n\n/**\n * @title  Staking\n * @notice Rewards stakers of given token with rewards in form of reward token, on a pro-rata basis.\n * @dev    Uses an ever increasing 'rewardPerTokenStored' variable to distribute rewards\n *         each time a write action is called in the contract. This allows for passive reward accrual.\n */\ncontract Staking is ReentrancyGuard, RewardsDistribution, Parameterized {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice reward token address\n    address public token;\n    /// @notice fee collecting address\n    address public feeCollector;\n\n    /// @notice timestamp for current period finish\n    uint256 public periodFinish;\n    /// @notice rewardRate for the rest of the period\n    uint256 public rewardRate;\n    /// @notice last time any user took action\n    uint256 public lastUpdateTime;\n    /// @notice accumulated per token reward since the beginning of time\n    uint256 public rewardPerTokenStored;\n    /// @notice amount of tokens that is used in reward per token calculation\n    uint256 public stakedTokens;\n\n    struct Stake {\n        uint256 stakeStart; // timestamp of stake creation\n        //\n        uint256 rewardPerTokenPaid; // user accumulated per token rewards\n        //\n        uint256 tokens; // total tokens staked by user\n        uint256 rewards; // current not-claimed rewards from last update\n        //\n        uint256 withdrawalPossibleAt; // timestamp after which stake can be removed without fee\n        bool isWithdrawing; // true = user call to remove stake\n    }\n\n    /// @dev each holder have one stake\n    /// @notice token stakes storage\n    mapping(address => Stake) public tokenStake;\n\n    /// @dev events\n    event Claimed(address indexed user, uint256 amount);\n    event StakeAdded(address indexed user, uint256 amount);\n    event StakeRemoveRequested(address indexed user);\n    event StakeRemoved(address indexed user, uint256 amount);\n    event Recalculation(uint256 reward);\n\n    /**\n     * @dev One time initialization function\n     * @param _token Staking token address\n     * @param _feeCollector fee collecting address\n     */\n    function init(address _token, address _feeCollector) external onlyOwner {\n        require(_token != address(0), \"_token address cannot be 0\");\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        require(token == address(0), \"init already done\");\n        token = _token;\n        feeCollector = _feeCollector;\n\n        timeToUnstake.value = WEEK;\n        unstakeFee.value = 1000;\n        periodLength.value = MONTH;\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        feeCollector = _feeCollector;\n    }\n\n    /**\n     * @dev Updates the reward for a given address,\n     *      before executing function\n     * @param _account address for which rewards will be updated\n     */\n    modifier updateReward(address _account) {\n        _updateReward(_account);\n        _;\n    }\n\n    /**\n     * @dev guards that the msg.sender has token stake\n     */\n    modifier hasStake() {\n        require(tokenStake[msg.sender].tokens > 0, \"nothing staked\");\n        _;\n    }\n\n    /**\n     * @dev checks if the msg.sender can withdraw requested unstake\n     */\n    modifier canUnstake() {\n        require(_canUnstake(), \"cannot unstake\");\n        _;\n    }\n\n    /**\n     * @dev checks if for the msg.sender there is possibility to\n     *      withdraw staked tokens without fee.\n     */\n    modifier cantUnstake() {\n        require(!_canUnstake(), \"unstake first\");\n        _;\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    /**\n     * @dev Updates reward\n     * @param _account address for which rewards will be updated\n     */\n    function _updateReward(address _account) internal {\n        uint256 newRewardPerTokenStored = currentRewardPerTokenStored();\n        // if statement protects against loss in initialization case\n        if (newRewardPerTokenStored > 0) {\n            rewardPerTokenStored = newRewardPerTokenStored;\n            lastUpdateTime = lastTimeRewardApplicable();\n\n            // setting of personal vars based on new globals\n            if (_account != address(0)) {\n                Stake storage s = tokenStake[_account];\n                if (!s.isWithdrawing) {\n                    s.rewards = _earned(_account);\n                    s.rewardPerTokenPaid = newRewardPerTokenStored;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Add tokens to staking contract\n     * @param _amount of tokens to stake\n     */\n    function addStake(uint256 _amount) external {\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Add tokens to staking contract by using permit to set allowance\n     * @param _amount of tokens to stake\n     * @param _deadline of permit signature\n     * @param _approveMax allowance for the token\n     */\n    function addStakeWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        uint256 value = _approveMax ? type(uint256).max : _amount;\n        IERC20(token).permit(msg.sender, address(this), value, _deadline, v, r, s);\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Internal add stake function\n     * @param _account selected staked tokens are credited to this address\n     * @param _amount of staked tokens\n     */\n    function _addStake(address _account, uint256 _amount) internal nonReentrant updateReward(_account) {\n        require(_amount > 0, \"zero amount\");\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // check for fee-on-transfer and proceed with received amount\n        _amount = _transferFrom(token, msg.sender, _amount);\n\n        if (ts.stakeStart == 0) {\n            // new stake\n            ts.stakeStart = block.timestamp;\n        }\n\n        // update account stake data\n        ts.tokens += _amount;\n        // update staking data\n        stakedTokens += _amount;\n    }\n\n    /**\n     * @dev Restake earned tokens and add them to token stake (instead of claiming)\n     */\n    function restake() external hasStake updateReward(msg.sender) {\n        Stake storage ts = tokenStake[msg.sender];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        uint256 rewards = ts.rewards;\n        require(rewards > 0, \"nothing to restake\");\n\n        delete ts.rewards;\n\n        // update account stake data\n        ts.tokens += rewards;\n        // update pool staking data\n        stakedTokens += rewards;\n\n        emit Claimed(msg.sender, rewards);\n        emit StakeAdded(msg.sender, rewards);\n    }\n\n    /**\n     * @dev Claims rewards for the msg.sender.\n     */\n    function claim() external {\n        _claim(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev Claim msg.sender rewards to provided address\n     * @param _recipient address where claimed tokens should be sent\n     */\n    function claimTo(address _recipient) external {\n        _claim(msg.sender, _recipient);\n    }\n\n    /**\n     * @dev Internal claim function. First updates rewards\n     *      and then transfers.\n     * @param _account claim rewards for this address\n     * @param _recipient claimed tokens are sent to this address\n     */\n    function _claim(address _account, address _recipient) internal nonReentrant hasStake updateReward(_account) {\n        uint256 rewards = tokenStake[_account].rewards;\n        require(rewards > 0, \"nothing to claim\");\n\n        delete tokenStake[_account].rewards;\n        _transfer(token, _recipient, rewards);\n\n        emit Claimed(_account, rewards);\n    }\n\n    /**\n     * @dev Request unstake for deposited tokens. Marks user token stake as withdrawing,\n     *      and start withdrawing period.\n     */\n    function requestUnstake() external {\n        _requestUnstake(msg.sender);\n        emit StakeRemoveRequested(msg.sender);\n    }\n\n    /**\n     * @dev Internal request unstake function. Update rewards for the user first.\n     * @param _account User address\n     */\n    function _requestUnstake(address _account) internal hasStake() updateReward(_account) {\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // update account stake data\n        ts.isWithdrawing = true;\n        ts.withdrawalPossibleAt = block.timestamp + timeToUnstake.value;\n        // update pool staking data\n        stakedTokens -= ts.tokens;\n    }\n\n    /**\n     * @dev Withdraw stake for msg.sender from stake (if possible)\n     */\n    function unstake() external nonReentrant hasStake canUnstake {\n        _unstake(false);\n    }\n\n    /**\n     * @dev Unstake requested stake at any time accepting penalty fee\n     */\n    function unstakeWithFee() external nonReentrant hasStake cantUnstake {\n        _unstake(true);\n    }\n\n    function _unstake(bool withFee) private {\n        Stake memory ts = tokenStake[msg.sender];\n        uint256 tokens;\n        uint256 rewards;\n        uint256 fee;\n\n        if (ts.isWithdrawing) {\n            tokens = withFee ? _minusFee(ts.tokens) : ts.tokens;\n            fee = withFee ? (ts.tokens - tokens) : 0;\n            rewards = ts.rewards;\n\n            emit StakeRemoved(msg.sender, ts.tokens);\n            delete tokenStake[msg.sender];\n        }\n\n        if (tokens + rewards > 0) {\n            _transfer(token, msg.sender, tokens + rewards);\n            if (fee > 0) {\n                _transfer(token, feeCollector, fee);\n            }\n\n            if (rewards > 0) {\n                emit Claimed(msg.sender, rewards);\n            }\n        }\n    }\n\n    /***************************************\n                    GETTERS\n    ****************************************/\n\n    /**\n     * @dev Gets the last applicable timestamp for this reward period\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return StableMath.min(block.timestamp, periodFinish);\n    }\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards per token since last update,\n     *      and sums with stored to give the new cumulative reward per token\n     * @return 'Reward' per staked token\n     */\n    function currentRewardPerTokenStored() public view returns (uint256) {\n        // If there is no staked tokens, avoid div(0)\n        if (stakedTokens == 0) {\n            return (rewardPerTokenStored);\n        }\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\n        uint256 timeDelta = lastTimeRewardApplicable() - lastUpdateTime;\n        uint256 rewardUnitsToDistribute = rewardRate * timeDelta;\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / stakedTokens\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedTokens);\n        // return summed rate\n        return (rewardPerTokenStored + unitsToDistributePerToken);\n    }\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards a user has earned\n     * @param _account user address\n     * @return Total reward amount earned\n     */\n    function _earned(address _account) internal view returns (uint256) {\n        Stake memory ts = tokenStake[_account];\n        if (ts.isWithdrawing) return ts.rewards;\n\n        // current rate per token - rate user previously received\n        uint256 userRewardDelta = currentRewardPerTokenStored() - ts.rewardPerTokenPaid;\n        uint256 userNewReward = ts.tokens.mulTruncate(userRewardDelta);\n\n        // add to previous rewards\n        return (ts.rewards + userNewReward);\n    }\n\n    /**\n     * @dev Calculates the claimable amounts for token stake from rewards\n     * @param _account user address\n     */\n    function claimable(address _account) external view returns (uint256) {\n        return _earned(_account);\n    }\n\n    /**\n     * @dev internal view to check if msg.sender can unstake\n     * @return true if user requested unstake and time for unstake has passed\n     */\n    function _canUnstake() private view returns (bool) {\n        return (tokenStake[msg.sender].isWithdrawing && block.timestamp >= tokenStake[msg.sender].withdrawalPossibleAt);\n    }\n\n    /**\n     * @dev external view to check if address can stake tokens\n     * @return true if user can stake tokens\n     */\n    function canStakeTokens(address _account) external view returns (bool) {\n        return !tokenStake[_account].isWithdrawing;\n    }\n\n    /***************************************\n                    REWARDER\n    ****************************************/\n\n    /**\n     * @dev Notifies the contract that new rewards have been added.\n     *      Calculates an updated rewardRate based on the rewards in period.\n     * @param _reward Units of token that have been added to the token pool\n     */\n    function notifyRewardAmount(uint256 _reward) external onlyRewardsDistributor updateReward(address(0)) {\n        uint256 currentTime = block.timestamp;\n\n        // pull tokens\n        require(_transferFrom(token, msg.sender, _reward) == _reward, \"Exclude Rewarder from fee\");\n\n        // If previous period over, reset rewardRate\n        if (currentTime >= periodFinish) {\n            rewardRate = _reward / periodLength.value;\n        }\n        // If additional reward to existing period, calc sum\n        else {\n            uint256 remaining = periodFinish - currentTime;\n\n            uint256 leftoverReward = remaining * rewardRate;\n            rewardRate = (_reward + leftoverReward) / periodLength.value;\n        }\n\n        lastUpdateTime = currentTime;\n        periodFinish = currentTime + periodLength.value;\n\n        emit Recalculation(_reward);\n    }\n\n    /***************************************\n                    TOKEN\n    ****************************************/\n\n    function _transferFrom(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        return IERC20(_token).safeTransferFromDeluxe(_from, _amount);\n    }\n\n    function _transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/external/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/helpers/RewardsDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { Ownable } from \"./Ownable.sol\";\n\ncontract RewardsDistributionData {\n    address public rewardsDistributor;\n}\n\ncontract RewardsDistribution is Ownable, RewardsDistributionData {\n    event RewardsDistributorChanged(address indexed previousDistributor, address indexed newDistributor);\n\n    /**\n     * @dev `rewardsDistributor` defaults to msg.sender on construction.\n     */\n    constructor() {\n        rewardsDistributor = msg.sender;\n        emit RewardsDistributorChanged(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Reward Distributor.\n     */\n    modifier onlyRewardsDistributor() {\n        require(msg.sender == rewardsDistributor, \"caller is not reward distributor\");\n        _;\n    }\n\n    /**\n     * @dev Change the rewardsDistributor - only called by owner\n     * @param _rewardsDistributor Address of the new distributor\n     */\n    function setRewardsDistribution(address _rewardsDistributor) external onlyOwner {\n        require(_rewardsDistributor != address(0), \"zero address\");\n\n        emit RewardsDistributorChanged(rewardsDistributor, _rewardsDistributor);\n        rewardsDistributor = _rewardsDistributor;\n    }\n}\n"
    },
    "contracts/helpers/Parameterized.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { Ownable } from \"./Ownable.sol\";\n\ncontract Parameterized is Ownable {\n    uint256 internal constant WEEK = 7 days;\n    uint256 internal constant MONTH = 30 days;\n\n    struct StakeParameters {\n        uint256 value;\n        uint256 lastChange;\n    }\n\n    /// @notice time to wait for unstake\n    StakeParameters public timeToUnstake;\n\n    /// @notice fee for premature unstake\n    /// @dev value 1000 = 10%\n    StakeParameters public unstakeFee;\n\n    /// @notice reward recalculation period length\n    StakeParameters public periodLength;\n\n    function _minusFee(uint256 val) internal view returns (uint256) {\n        return val - ((val * unstakeFee.value) / 10000);\n    }\n\n    function updateFee(uint256 val) external onlyOwner {\n        require(block.timestamp > unstakeFee.lastChange + WEEK, \"soon\");\n        require(val <= 2500, \"max fee is 25%\");\n        unstakeFee.lastChange = block.timestamp;\n        unstakeFee.value = val;\n    }\n\n    function updateTimeToUnstake(uint256 val) external onlyOwner {\n        require(block.timestamp > timeToUnstake.lastChange + WEEK, \"soon\");\n        require(val <= 2 * MONTH, \"max delay is 60 days\");\n        timeToUnstake.lastChange = block.timestamp;\n        timeToUnstake.value = val;\n    }\n\n    function updatePeriodLength(uint256 val) external onlyOwner {\n        require(block.timestamp > periodLength.lastChange + WEEK, \"soon\");\n        require(val >= WEEK, \"min period length is 7 days\");\n        periodLength.lastChange = block.timestamp;\n        periodLength.value = val;\n    }\n}\n"
    },
    "contracts/staking/PixelFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable no-empty-blocks */\npragma solidity 0.8.6;\n\nimport { ReentrancyGuard } from \"../external/openzeppelin/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"../libraries/SafeERC20.sol\";\nimport { StableMath } from \"../libraries/StableMath.sol\";\n\nimport { Parameterized } from \"../helpers/Parameterized.sol\";\n\n/**\n * @title  PixelFarm\n * @notice Rewards stakers of given token with rewards in form of promo token.\n */\ncontract PixelFarm is ReentrancyGuard, Parameterized {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice staking token address\n    address public stakingToken;\n    /// @notice promo token address\n    address public promoToken;\n    /// @notice fee collecting address\n    address public feeCollector;\n    /// @notice rewardRate for the promo token\n    uint256 public rewardRate;\n    /// @notice last time any user took action\n    uint256 public lastUpdateTime;\n    /// @notice accumulated per token reward since the beginning of time\n    uint256 public rewardPerTokenStored;\n\n    struct Stake {\n        uint256 start; // timestamp of stake creation\n        //\n        uint256 rewardPerTokenPaid; // user accumulated per token rewards\n        //\n        uint256 tokens; // total tokens staked by user\n        uint256 rewards; // current not-claimed rewards from last update\n        //\n        uint256 withdrawalPossibleAt; // timestamp after which stake can be removed without fee\n        bool isWithdrawing; // true = user call to remove stake\n    }\n\n    /// @dev each holder have one stake\n    /// @notice token stakes storage\n    mapping(address => Stake) public tokenStake;\n\n    /// @dev events\n    event Claimed(address indexed user, uint256 amount);\n    event StakeAdded(address indexed user, uint256 amount);\n    event StakeRemoveRequested(address indexed user);\n    event StakeRemoved(address indexed user, uint256 amount);\n\n    /**\n     * @dev One time initialization function\n     * @param _stakingToken staking token address\n     * @param _promoToken promo token address\n     * @param _feeCollector fee collecting address\n     */\n    function init(\n        address _stakingToken,\n        address _promoToken,\n        address _feeCollector\n    ) external onlyOwner {\n        require(_stakingToken != address(0), \"_stakingToken address cannot be 0\");\n        require(_promoToken != address(0), \"_promoToken address cannot be 0\");\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        require(stakingToken == address(0), \"init already done\");\n        stakingToken = _stakingToken;\n        promoToken = _promoToken;\n        feeCollector = _feeCollector;\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        feeCollector = _feeCollector;\n    }\n\n    /**\n     * @dev Updates the reward for a given address,\n     *      before executing function\n     * @param _account address for which rewards will be updated\n     */\n    modifier updateReward(address _account) {\n        _updateReward(_account);\n        _;\n    }\n\n    /**\n     * @dev guards that the msg.sender has token stake\n     */\n    modifier hasStake() {\n        require(tokenStake[msg.sender].tokens > 0, \"nothing staked\");\n        _;\n    }\n\n    /**\n     * @dev checks if the msg.sender can withdraw requested unstake\n     */\n    modifier canUnstake() {\n        require(_canUnstake(), \"cannot unstake\");\n        _;\n    }\n\n    /**\n     * @dev checks if for the msg.sender there is possibility to\n     *      withdraw staked tokens without fee.\n     */\n    modifier cantUnstake() {\n        require(!_canUnstake(), \"unstake first\");\n        _;\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    /**\n     * @dev Updates reward\n     * @param _account address for which rewards will be updated\n     */\n    function _updateReward(address _account) internal {\n        uint256 newRewardPerTokenStored = currentRewardPerTokenStored();\n        // if statement protects against loss in initialization case\n        if (newRewardPerTokenStored > 0) {\n            rewardPerTokenStored = newRewardPerTokenStored;\n            lastUpdateTime = block.timestamp;\n\n            // setting of personal vars based on new globals\n            if (_account != address(0)) {\n                Stake storage s = tokenStake[_account];\n                if (!s.isWithdrawing) {\n                    s.rewards = _earned(_account);\n                    s.rewardPerTokenPaid = newRewardPerTokenStored;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Add tokens to staking contract\n     * @param _amount of tokens to stake\n     */\n    function addStake(uint256 _amount) external {\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Add tokens to staking contract by using permit to set allowance\n     * @param _amount of tokens to stake\n     * @param _deadline of permit signature\n     * @param _approveMax allowance for the token\n     */\n    function addStakeWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        uint256 value = _approveMax ? type(uint256).max : _amount;\n        IERC20(stakingToken).permit(msg.sender, address(this), value, _deadline, v, r, s);\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Internal add stake function\n     * @param _account staking tokens are credited to this address\n     * @param _amount of staked tokens\n     */\n    function _addStake(address _account, uint256 _amount) internal nonReentrant updateReward(_account) {\n        require(_amount > 0, \"zero amount\");\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // check for fee-on-transfer and proceed with received amount\n        _amount = _transferFrom(stakingToken, msg.sender, _amount);\n\n        if (ts.start == 0) {\n            // new stake\n            ts.start = block.timestamp;\n        }\n\n        // update account stake data\n        ts.tokens += _amount;\n    }\n\n    /**\n     * @dev Claims rewards for the msg.sender.\n     */\n    function claim() external {\n        _claim(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev Claim msg.sender rewards to provided address\n     * @param _recipient address where claimed tokens should be sent\n     */\n    function claimTo(address _recipient) external {\n        _claim(msg.sender, _recipient);\n    }\n\n    /**\n     * @dev Internal claim function. First updates rewards\n     *      and then transfers.\n     * @param _account claim rewards for this address\n     * @param _recipient claimed tokens are sent to this address\n     */\n    function _claim(address _account, address _recipient) internal nonReentrant hasStake updateReward(_account) {\n        uint256 rewards = tokenStake[_account].rewards;\n        if (rewards > 0) {\n            try IPromo(promoToken).mintTo(_recipient, rewards) returns (bool minted) {\n                if (minted) {\n                    delete tokenStake[_account].rewards;\n                    emit Claimed(_recipient, rewards);\n                }\n            } catch {\n                // no need for revert when\n                // promo tokens are not minted.\n            }\n        }\n    }\n\n    /**\n     * @dev Request unstake for deposited tokens. Marks user token stake as withdrawing,\n     *      and start withdrawing period.\n     */\n    function requestUnstake() external {\n        _requestUnstake(msg.sender);\n        emit StakeRemoveRequested(msg.sender);\n    }\n\n    /**\n     * @dev Internal request unstake function. Update rewards for the user first.\n     * @param _account User address\n     */\n    function _requestUnstake(address _account) internal hasStake() updateReward(_account) {\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // update account stake data\n        ts.isWithdrawing = true;\n        ts.withdrawalPossibleAt = block.timestamp + timeToUnstake.value;\n    }\n\n    /**\n     * @dev Withdraw stake for msg.sender from stake (if possible)\n     */\n    function unstake() external nonReentrant hasStake canUnstake {\n        _unstake(false);\n    }\n\n    /**\n     * @dev Unstake requested stake at any time accepting penalty fee\n     */\n    function unstakeWithFee() external nonReentrant hasStake cantUnstake {\n        _unstake(true);\n    }\n\n    function _unstake(bool withFee) private {\n        Stake memory ts = tokenStake[msg.sender];\n        uint256 tokens;\n        uint256 rewards;\n        uint256 fee;\n\n        if (ts.isWithdrawing) {\n            tokens = withFee ? _minusFee(ts.tokens) : ts.tokens;\n            fee = withFee ? (ts.tokens - tokens) : 0;\n            rewards = ts.rewards;\n\n            emit StakeRemoved(msg.sender, ts.tokens);\n            delete tokenStake[msg.sender];\n        }\n\n        if (tokens > 0) {\n            _transfer(stakingToken, msg.sender, tokens);\n            if (fee > 0) {\n                _transfer(stakingToken, feeCollector, fee);\n            }\n        }\n\n        if (rewards > 0) {\n            try IPromo(promoToken).mintTo(msg.sender, rewards) returns (bool minted) {\n                if (minted) {\n                    emit Claimed(msg.sender, rewards);\n                }\n            } catch {\n                // we let user withdraw in case of an error, and no revert when\n                // promo tokens are not minted.\n            }\n        }\n    }\n\n    /***************************************\n                    GETTERS\n    ****************************************/\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards per token since last update,\n     *      and sums with stored to give the new cumulative reward per token\n     * @return 'Reward' per staked token\n     */\n    function currentRewardPerTokenStored() public view returns (uint256) {\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\n        uint256 timeDelta = block.timestamp - lastUpdateTime;\n        uint256 unitsToDistributePerToken = rewardRate * timeDelta;\n        // return summed rate\n        return (rewardPerTokenStored + unitsToDistributePerToken);\n    }\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards an user has earned\n     * @param _account user address\n     * @return Total reward amount earned\n     */\n    function _earned(address _account) internal view returns (uint256) {\n        Stake memory ts = tokenStake[_account];\n        if (ts.isWithdrawing || ts.tokens == 0) return ts.rewards;\n\n        // current rate per token - rate user previously received\n        uint256 userRewardDelta = currentRewardPerTokenStored() - ts.rewardPerTokenPaid;\n        uint256 userNewReward = ts.tokens.mulTruncate(userRewardDelta);\n\n        // add to previous rewards\n        return (ts.rewards + userNewReward);\n    }\n\n    /**\n     * @dev Calculates the claimable amounts for token stake from rewards\n     * @param _account user address\n     */\n    function claimable(address _account) external view returns (uint256) {\n        return _earned(_account);\n    }\n\n    /**\n     * @dev internal view to check if msg.sender can unstake\n     * @return true if user requested unstake and time for unstake has passed\n     */\n    function _canUnstake() private view returns (bool) {\n        return (tokenStake[msg.sender].isWithdrawing && block.timestamp >= tokenStake[msg.sender].withdrawalPossibleAt);\n    }\n\n    /**\n     * @dev external view to check if address can stake tokens\n     * @return true if user can stake tokens\n     */\n    function canStakeTokens(address _account) external view returns (bool) {\n        return !tokenStake[_account].isWithdrawing;\n    }\n\n    /***************************************\n                    REWARDER\n    ****************************************/\n\n    /**\n     * @dev Notifies the contract that new rewardRate have been added.\n     * @param _rewardRate amount of tokens released per block per token staked\n     */\n    function notifyRewardRate(uint256 _rewardRate) external onlyOwner updateReward(address(0)) {\n        rewardRate = _rewardRate;\n        lastUpdateTime = block.timestamp;\n    }\n\n    /***************************************\n                    TOKEN\n    ****************************************/\n\n    function _transferFrom(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        return IERC20(_token).safeTransferFromDeluxe(_from, _amount);\n    }\n\n    function _transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n\ninterface IPromo {\n    function mintTo(address account, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/staking/LPMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { ReentrancyGuard } from \"../external/openzeppelin/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"../libraries/SafeERC20.sol\";\nimport { StableMath } from \"../libraries/StableMath.sol\";\n\nimport { RewardsDistribution } from \"../helpers/RewardsDistribution.sol\";\nimport { Parameterized } from \"../helpers/Parameterized.sol\";\n\n/**\n * @title  Staking\n * @notice Rewards stakers of given token with rewards in form of reward token, on a pro-rata basis.\n * @dev    Uses an ever increasing 'rewardPerTokenStored' variable to distribute rewards\n *         each time a write action is called in the contract. This allows for passive reward accrual.\n */\ncontract LPMining is ReentrancyGuard, RewardsDistribution, Parameterized {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice staking token address\n    address public stakingToken;\n    /// @notice rewards token address\n    address public rewardsToken;\n    /// @notice fee collecting address\n    address public feeCollector;\n\n    /// @notice timestamp for current period finish\n    uint256 public periodFinish;\n    /// @notice rewardRate for the rest of the period\n    uint256 public rewardRate;\n    /// @notice last time any user took action\n    uint256 public lastUpdateTime;\n    /// @notice accumulated per token reward since the beginning of time\n    uint256 public rewardPerTokenStored;\n    /// @notice amount of tokens that is used in reward per token calculation\n    uint256 public stakedTokens;\n\n    struct Stake {\n        uint256 stakeStart; // timestamp of stake creation\n        //\n        uint256 rewardPerTokenPaid; // user accumulated per token rewards\n        //\n        uint256 tokens; // total tokens staked by user\n        uint256 rewards; // current not-claimed rewards from last update\n        //\n        uint256 withdrawalPossibleAt; // timestamp after which stake can be removed without fee\n        bool isWithdrawing; // true = user call to remove stake\n    }\n\n    /// @dev each holder have one stake\n    /// @notice token stakes storage\n    mapping(address => Stake) public tokenStake;\n\n    /// @dev events\n    event Claimed(address indexed user, uint256 amount);\n    event StakeAdded(address indexed user, uint256 amount);\n    event StakeRemoveRequested(address indexed user);\n    event StakeRemoved(address indexed user, uint256 amount);\n    event Recalculation(uint256 reward);\n\n    /**\n     * @dev One time initialization function\n     * @param _stakingToken staking token address\n     * @param _rewardsToken rewards token address\n     * @param _feeCollector fee collecting address\n     */\n    function init(\n        address _stakingToken,\n        address _rewardsToken,\n        address _feeCollector\n    ) external onlyOwner {\n        require(_stakingToken != address(0), \"_stakingToken address cannot be 0\");\n        require(_rewardsToken != address(0), \"_rewardsToken address cannot be 0\");\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        require(stakingToken == address(0), \"init already done\");\n        stakingToken = _stakingToken;\n        rewardsToken = _rewardsToken;\n        feeCollector = _feeCollector;\n\n        timeToUnstake.value = WEEK;\n        unstakeFee.value = 1000;\n        periodLength.value = MONTH;\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\n        feeCollector = _feeCollector;\n    }\n\n    /**\n     * @dev Updates the reward for a given address,\n     *      before executing function\n     * @param _account address for which rewards will be updated\n     */\n    modifier updateReward(address _account) {\n        _updateReward(_account);\n        _;\n    }\n\n    /**\n     * @dev guards that the msg.sender has token stake\n     */\n    modifier hasStake() {\n        require(tokenStake[msg.sender].tokens > 0, \"nothing staked\");\n        _;\n    }\n\n    /**\n     * @dev checks if the msg.sender can withdraw requested unstake\n     */\n    modifier canUnstake() {\n        require(_canUnstake(), \"cannot unstake\");\n        _;\n    }\n\n    /**\n     * @dev checks if for the msg.sender there is possibility to\n     *      withdraw staked tokens without fee.\n     */\n    modifier cantUnstake() {\n        require(!_canUnstake(), \"unstake first\");\n        _;\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    /**\n     * @dev Updates reward\n     * @param _account address for which rewards will be updated\n     */\n    function _updateReward(address _account) internal {\n        uint256 newRewardPerTokenStored = currentRewardPerTokenStored();\n        // if statement protects against loss in initialization case\n        if (newRewardPerTokenStored > 0) {\n            rewardPerTokenStored = newRewardPerTokenStored;\n            lastUpdateTime = lastTimeRewardApplicable();\n\n            // setting of personal vars based on new globals\n            if (_account != address(0)) {\n                Stake storage s = tokenStake[_account];\n                if (!s.isWithdrawing) {\n                    s.rewards = _earned(_account);\n                    s.rewardPerTokenPaid = newRewardPerTokenStored;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Add tokens to staking contract\n     * @param _amount of tokens to stake\n     */\n    function addStake(uint256 _amount) external {\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Add tokens to staking contract by using permit to set allowance\n     * @param _amount of tokens to stake\n     * @param _deadline of permit signature\n     * @param _approveMax allowance for the token\n     */\n    function addStakeWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        uint256 value = _approveMax ? type(uint256).max : _amount;\n        IERC20(stakingToken).permit(msg.sender, address(this), value, _deadline, v, r, s);\n        _addStake(msg.sender, _amount);\n        emit StakeAdded(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Internal add stake function\n     * @param _account staking tokens are credited to this address\n     * @param _amount of staked tokens\n     */\n    function _addStake(address _account, uint256 _amount) internal nonReentrant updateReward(_account) {\n        require(_amount > 0, \"zero amount\");\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // check for fee-on-transfer and proceed with received amount\n        _amount = _transferFrom(stakingToken, msg.sender, _amount);\n\n        if (ts.stakeStart == 0) {\n            // new stake\n            ts.stakeStart = block.timestamp;\n        }\n\n        // update account stake data\n        ts.tokens += _amount;\n        // update staking data\n        stakedTokens += _amount;\n    }\n\n    /**\n     * @dev Claims rewards for the msg.sender.\n     */\n    function claim() external {\n        _claim(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev Claim msg.sender rewards to provided address\n     * @param _recipient address where claimed tokens should be sent\n     */\n    function claimTo(address _recipient) external {\n        _claim(msg.sender, _recipient);\n    }\n\n    /**\n     * @dev Internal claim function. First updates rewards\n     *      and then transfers.\n     * @param _account claim rewards for this address\n     * @param _recipient claimed tokens are sent to this address\n     */\n    function _claim(address _account, address _recipient) internal nonReentrant hasStake updateReward(_account) {\n        uint256 rewards = tokenStake[_account].rewards;\n        require(rewards > 0, \"nothing to claim\");\n\n        delete tokenStake[_account].rewards;\n        _transfer(rewardsToken, _recipient, rewards);\n\n        emit Claimed(_account, rewards);\n    }\n\n    /**\n     * @dev Request unstake for deposited tokens. Marks user token stake as withdrawing,\n     *      and start withdrawing period.\n     */\n    function requestUnstake() external {\n        _requestUnstake(msg.sender);\n        emit StakeRemoveRequested(msg.sender);\n    }\n\n    /**\n     * @dev Internal request unstake function. Update rewards for the user first.\n     * @param _account User address\n     */\n    function _requestUnstake(address _account) internal hasStake() updateReward(_account) {\n        Stake storage ts = tokenStake[_account];\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\n\n        // update account stake data\n        ts.isWithdrawing = true;\n        ts.withdrawalPossibleAt = block.timestamp + timeToUnstake.value;\n        // update pool staking data\n        stakedTokens -= ts.tokens;\n    }\n\n    /**\n     * @dev Withdraw stake for msg.sender from stake (if possible)\n     */\n    function unstake() external nonReentrant hasStake canUnstake {\n        _unstake(false);\n    }\n\n    /**\n     * @dev Unstake requested stake at any time accepting penalty fee\n     */\n    function unstakeWithFee() external nonReentrant hasStake cantUnstake {\n        _unstake(true);\n    }\n\n    function _unstake(bool withFee) private {\n        Stake memory ts = tokenStake[msg.sender];\n        uint256 tokens;\n        uint256 rewards;\n        uint256 fee;\n\n        if (ts.isWithdrawing) {\n            tokens = withFee ? _minusFee(ts.tokens) : ts.tokens;\n            fee = withFee ? (ts.tokens - tokens) : 0;\n            rewards = ts.rewards;\n\n            emit StakeRemoved(msg.sender, ts.tokens);\n            delete tokenStake[msg.sender];\n        }\n\n        if (tokens > 0) {\n            _transfer(stakingToken, msg.sender, tokens);\n            if (fee > 0) {\n                _transfer(stakingToken, feeCollector, fee);\n            }\n        }\n\n        if (rewards > 0) {\n            _transfer(rewardsToken, msg.sender, rewards);\n            emit Claimed(msg.sender, rewards);\n        }\n    }\n\n    /***************************************\n                    GETTERS\n    ****************************************/\n\n    /**\n     * @dev Gets the last applicable timestamp for this reward period\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return StableMath.min(block.timestamp, periodFinish);\n    }\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards per token since last update,\n     *      and sums with stored to give the new cumulative reward per token\n     * @return 'Reward' per staked token\n     */\n    function currentRewardPerTokenStored() public view returns (uint256) {\n        // If there is no staked tokens, avoid div(0)\n        if (stakedTokens == 0) {\n            return (rewardPerTokenStored);\n        }\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\n        uint256 timeDelta = lastTimeRewardApplicable() - lastUpdateTime;\n        uint256 rewardUnitsToDistribute = rewardRate * timeDelta;\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / stakedTokens\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedTokens);\n        // return summed rate\n        return (rewardPerTokenStored + unitsToDistributePerToken);\n    }\n\n    /**\n     * @dev Calculates the amount of unclaimed rewards a user has earned\n     * @param _account user address\n     * @return Total reward amount earned\n     */\n    function _earned(address _account) internal view returns (uint256) {\n        Stake memory ts = tokenStake[_account];\n        if (ts.isWithdrawing) return ts.rewards;\n\n        // current rate per token - rate user previously received\n        uint256 userRewardDelta = currentRewardPerTokenStored() - ts.rewardPerTokenPaid;\n        uint256 userNewReward = ts.tokens.mulTruncate(userRewardDelta);\n\n        // add to previous rewards\n        return (ts.rewards + userNewReward);\n    }\n\n    /**\n     * @dev Calculates the claimable amounts for token stake from rewards\n     * @param _account user address\n     */\n    function claimable(address _account) external view returns (uint256) {\n        return _earned(_account);\n    }\n\n    /**\n     * @dev internal view to check if msg.sender can unstake\n     * @return true if user requested unstake and time for unstake has passed\n     */\n    function _canUnstake() private view returns (bool) {\n        return (tokenStake[msg.sender].isWithdrawing && block.timestamp >= tokenStake[msg.sender].withdrawalPossibleAt);\n    }\n\n    /**\n     * @dev external view to check if address can stake tokens\n     * @return true if user can stake tokens\n     */\n    function canStakeTokens(address _account) external view returns (bool) {\n        return !tokenStake[_account].isWithdrawing;\n    }\n\n    /***************************************\n                    REWARDER\n    ****************************************/\n\n    /**\n     * @dev Notifies the contract that new rewards have been added.\n     *      Calculates an updated rewardRate based on the rewards in period.\n     * @param _reward Units of rewardsToken that have been added to the token pool\n     */\n    function notifyRewardAmount(uint256 _reward) external onlyRewardsDistributor updateReward(address(0)) {\n        uint256 currentTime = block.timestamp;\n\n        // pull tokens\n        require(_transferFrom(rewardsToken, msg.sender, _reward) == _reward, \"Exclude Rewarder from fee\");\n\n        // If previous period over, reset rewardRate\n        if (currentTime >= periodFinish) {\n            rewardRate = _reward / periodLength.value;\n        }\n        // If additional reward to existing period, calc sum\n        else {\n            uint256 remaining = periodFinish - currentTime;\n\n            uint256 leftoverReward = remaining * rewardRate;\n            rewardRate = (_reward + leftoverReward) / periodLength.value;\n        }\n\n        lastUpdateTime = currentTime;\n        periodFinish = currentTime + periodLength.value;\n\n        emit Recalculation(_reward);\n    }\n\n    /***************************************\n                    TOKEN\n    ****************************************/\n\n    function _transferFrom(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        return IERC20(_token).safeTransferFromDeluxe(_from, _amount);\n    }\n\n    function _transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/Hololoot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { EIP712 } from \"./external/openzeppelin/draft-EIP712.sol\";\nimport { ECDSA } from \"./external/openzeppelin/ECDSA.sol\";\n\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"./helpers/Ownable.sol\";\nimport { TransactionThrottler } from \"./helpers/TransactionThrottler.sol\";\nimport { Constants } from \"./libraries/Constants.sol\";\n\ncontract Hololoot is IERC20, EIP712, Ownable, TransactionThrottler {\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public override nonces;\n\n    mapping(address => bool) private _excludedFromFees;\n    // BPS means divide by 10,000 to get decimal\n    uint256 private constant MAX_TRANSFER_FEE_BPS = 1000;\n    uint256 private constant BPS_MULTIPLIER = 10000;\n    uint256 public transferFeeBPS;\n    address public feeContract;\n    bool private isFeeManager;\n\n    event MarkedExcluded(address indexed account, bool isExcluded);\n    event FeeBPS(uint256 feeBPS);\n    event FeeContractChanged(address feeContract, bool isFeeManager);\n\n    constructor(address _admin) EIP712(Constants.getName(), \"1\") {\n        setExcludedFromFees(_admin, true);\n\n        _setOwner(_admin);\n        _mint(_admin, 100_000_000 * 10**18);\n    }\n\n    function name() external pure returns (string memory) {\n        return Constants.getName();\n    }\n\n    function symbol() external pure returns (string memory) {\n        return Constants.getSymbol();\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return Constants.getDecimals();\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function _mint(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external override returns (bool) {\n        _burn(msg.sender, amount);\n        return true;\n    }\n\n    function burnFrom(address account, uint256 amount) external override returns (bool) {\n        uint256 currentAllowance = _allowances[account][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, msg.sender, currentAllowance - amount);\n        }\n        _burn(account, amount);\n        return true;\n    }\n\n    function _burn(address account, uint256 amount) private {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) external view override returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        if (currentAllowance < type(uint256).max) {\n            // DEXes can use max allowance\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private transactionThrottler(sender, recipient, amount) {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount is 0\");\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        uint256 fee;\n        if (feeContract != address(0) && transferFeeBPS > 0 && !_excludedFromFees[sender] && !_excludedFromFees[recipient]) {\n            fee = (amount * transferFeeBPS) / BPS_MULTIPLIER;\n            _balances[feeContract] += fee;\n            emit Transfer(sender, feeContract, fee);\n\n            if (isFeeManager && IFeeManager(feeContract).canSyncFee(sender, recipient)) {\n                IFeeManager(feeContract).syncFee();\n            }\n        }\n\n        uint256 sendAmount = amount - fee;\n        _balances[sender] -= amount;\n        _balances[recipient] += sendAmount;\n        emit Transfer(sender, recipient, sendAmount);\n    }\n\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function permit(\n        address _owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        // Revert faster here then later on signature (gas saving for user)\n        require(_owner != address(0), \"ERC20Permit: Permit from zero address\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, spender, value, nonces[_owner]++, deadline));\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == _owner, \"ERC20Permit: invalid signature\");\n\n        _approve(_owner, spender, value);\n    }\n\n    function isExcludedFromFees(address account) external view returns (bool) {\n        return _excludedFromFees[account];\n    }\n\n    function setExcludedFromFees(address account, bool isExcluded) public onlyOwner {\n        require(account != address(0), \"Zero address\");\n        _excludedFromFees[account] = isExcluded;\n        emit MarkedExcluded(account, isExcluded);\n    }\n\n    function setTransferFeeBPS(uint256 fee) external onlyOwner {\n        require(fee <= MAX_TRANSFER_FEE_BPS, \"Fee is outside of range 0-1000\");\n        transferFeeBPS = fee;\n        emit FeeBPS(transferFeeBPS);\n    }\n\n    function changeFeeContract(address _feeContract, bool _isFeeManager) external onlyOwner {\n        feeContract = _feeContract;\n        isFeeManager = _isFeeManager;\n        emit FeeContractChanged(feeContract, isFeeManager);\n    }\n}\n\ninterface IFeeManager {\n    function canSyncFee(address sender, address recipient) external view returns (bool);\n\n    function syncFee() external;\n}\n"
    },
    "contracts/external/openzeppelin/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "contracts/external/openzeppelin/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/helpers/TransactionThrottler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { Ownable } from \"./Ownable.sol\";\n\ncontract TransactionThrottler is Ownable {\n    bool private _initlialized;\n    bool private _restrictionActive;\n    uint256 private _tradingStart;\n    uint256 private _maxTransferAmount;\n    uint256 private constant _delayBetweenTx = 30;\n    mapping(address => bool) private _isWhitelisted;\n    mapping(address => bool) private _isUnthrottled;\n    mapping(address => uint256) private _previousTx;\n\n    event TradingTimeChanged(uint256 tradingTime);\n    event RestrictionActiveChanged(bool active);\n    event MaxTransferAmountChanged(uint256 maxTransferAmount);\n    event MarkedWhitelisted(address indexed account, bool isWhitelisted);\n    event MarkedUnthrottled(address indexed account, bool isUnthrottled);\n\n    function initAntibot() external onlyOwner() {\n        require(!_initlialized, \"Protection: Already initialized\");\n        _initlialized = true;\n        _isUnthrottled[owner] = true;\n        _tradingStart = 1639407600;\n        _maxTransferAmount = 15_000 * 10**18;\n        _restrictionActive = true;\n\n        emit MarkedUnthrottled(owner, true);\n        emit TradingTimeChanged(_tradingStart);\n        emit MaxTransferAmountChanged(_maxTransferAmount);\n        emit RestrictionActiveChanged(_restrictionActive);\n    }\n\n    function setTradingStart(uint256 _time) external onlyOwner() {\n        require(_tradingStart > block.timestamp, \"Protection: To late\");\n        _tradingStart = _time;\n        emit TradingTimeChanged(_tradingStart);\n    }\n\n    function setMaxTransferAmount(uint256 _amount) external onlyOwner() {\n        _maxTransferAmount = _amount;\n        emit MaxTransferAmountChanged(_maxTransferAmount);\n    }\n\n    function setRestrictionActive(bool _active) external onlyOwner() {\n        _restrictionActive = _active;\n        emit RestrictionActiveChanged(_restrictionActive);\n    }\n\n    function unthrottleAccount(address _account, bool _unthrottled) external onlyOwner() {\n        require(_account != address(0), \"Zero address\");\n        _isUnthrottled[_account] = _unthrottled;\n        emit MarkedUnthrottled(_account, _unthrottled);\n    }\n\n    function isUnthrottled(address account) external view returns (bool) {\n        return _isUnthrottled[account];\n    }\n\n    function whitelistAccount(address _account, bool _whitelisted) external onlyOwner() {\n        require(_account != address(0), \"Zero address\");\n        _isWhitelisted[_account] = _whitelisted;\n        emit MarkedWhitelisted(_account, _whitelisted);\n    }\n\n    function isWhitelisted(address account) external view returns (bool) {\n        return _isWhitelisted[account];\n    }\n\n    modifier transactionThrottler(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) {\n        require(sender != recipient, \"sender is recipient\");\n        if (_restrictionActive && !_isUnthrottled[recipient] && !_isUnthrottled[sender]) {\n            require(block.timestamp >= _tradingStart, \"Protection: Transfers disabled\");\n\n            if (_maxTransferAmount > 0) {\n                require(amount <= _maxTransferAmount, \"Protection: Limit exceeded\");\n            }\n\n            if (!_isWhitelisted[recipient]) {\n                require(_previousTx[recipient] + _delayBetweenTx <= block.timestamp, \"Protection: 30 sec/tx allowed\");\n                _previousTx[recipient] = block.timestamp;\n            }\n\n            if (!_isWhitelisted[sender]) {\n                require(_previousTx[sender] + _delayBetweenTx <= block.timestamp, \"Protection: 30 sec/tx allowed\");\n                _previousTx[sender] = block.timestamp;\n            }\n        }\n        _;\n    }\n}\n"
    },
    "contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nlibrary Constants {\n    string private constant _name = \"Hololoot Coin\";\n    string private constant _symbol = \"HOL\";\n    uint8 private constant _decimals = 18;\n\n    function getName() internal pure returns (string memory) {\n        return _name;\n    }\n\n    function getSymbol() internal pure returns (string memory) {\n        return _symbol;\n    }\n\n    function getDecimals() internal pure returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/mocks/OwnableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/* solhint-disable no-empty-blocks */\npragma solidity 0.8.6;\n\nimport { Ownable } from \"../helpers/Ownable.sol\";\n\ncontract OwnableMock is Ownable {}\n"
    },
    "contracts/Holopixel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport { Ownable } from \"./helpers/Ownable.sol\";\n\ncontract Holopixel is Ownable {\n    string private _name;\n    string private _symbol = \"Holopixel\";\n    uint8 private constant _decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _whitelisted;\n\n    mapping(address => bool) private _minters;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(address _admin) {\n        _setOwner(_admin);\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function setName(string memory name_) external onlyOwner {\n        _name = name_;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function setSymbol(string memory symbol_) external onlyOwner {\n        _symbol = symbol_;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function mint(uint256 amount) external onlyOwner returns (bool) {\n        _mint(msg.sender, amount);\n        return true;\n    }\n\n    function mintTo(address account, uint256 amount) external returns (bool) {\n        if (_minters[msg.sender]) {\n            _mint(account, amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _mint(address account, uint256 amount) private {\n        require(account != address(0), \"mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external onlyOwner returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n    function _burn(address account, uint256 amount) private {\n        require(account != address(0), \"burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) external view returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        if (currentAllowance < type(uint256).max) {\n            // DEXes can use max allowance\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private onlyWhitelisted(sender, recipient) {\n        require(sender != address(0), \"transfer from the zero address\");\n        require(recipient != address(0), \"transfer to the zero address\");\n        require(amount > 0, \"transfer amount is 0\");\n        require(_balances[sender] >= amount, \"transfer amount exceeds balance\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(_owner != address(0), \"approve from the zero address\");\n        require(spender != address(0), \"approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    function isWhitelisted(address account) external view returns (bool) {\n        return _whitelisted[account];\n    }\n\n    function setWhitelisted(address account, bool whitelisted) public onlyOwner {\n        require(account != address(0), \"zero address\");\n        _whitelisted[account] = whitelisted;\n    }\n\n    function isMinter(address account) external view returns (bool) {\n        return _minters[account];\n    }\n\n    function setMinter(address account, bool minter) public onlyOwner {\n        require(account != address(0), \"zero address\");\n        _minters[account] = minter;\n    }\n\n    modifier onlyWhitelisted(address sender, address recipient) {\n        require(_whitelisted[sender] || _whitelisted[recipient], \"only whitelisted\");\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}